#!/usr/bin/env bash

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]
then
	set -Eeuo pipefail
fi
OLD_IFS="${IFS}"
TXNS_FILE_PATH='bashbudget_txns.csv'
function usage {
  local exit_code=${1-0}
  cat <<EOF # remove the space between << and EOF, this is due to web plugin issue
Usage: $(basename "${BASH_SOURCE[0]}") [import|reports] [options] file1 file2 ...

Track transactions and generate reports on spending

Commands:
-h, --help      				  Print this help and exit
import <file> --importer <file>   Import and normalize transactions
reports totals [--from --to]      Generate category/monthly total
EOF
  exit "${exit_code}"
}

function msg {
  echo >&2 -e "${@}"
}

function die {
  local msg=$1
  local code=${2-1} # default exit status 1
  msg "$msg"
  exit "$code"
}

function parse_ini {
	 local file="${1?Must provide a path to an INI config file}"
	 local -n out="${2?Must provide an associative array output variable}"
	 # declare -gA INI_CONFIG=()
	 # export INI_CONFIG
	 local line_num=0
	 local line key value

	 while IFS= read -r line || [[ -n $line ]]; do
		line_num=$((line_num + 1))
		line="${line#"${line%%[![:space:]]*}"}"  # ltrim
		# line="${line%"${line##*[![:space:]]}"}"  # rtrim

		# Skip comments
		if [[ "${line}" =~ ^[[:space:]]*[#\;] ]] || [[ "${line}" =~ ^[[:space:]]*$ ]] ; then
		  continue
		fi

		# Parse key=value lines
		if [[ "${line}" =~ ^([^[:space:]=]+)=(.*)$ ]]; then
		  key="${BASH_REMATCH[1]}"
		  value="${BASH_REMATCH[2]}"
		  out["${key}"]="${value}"
		  continue
		fi

	   # Everything else is invalid
	   msg "parse_ini: Invalid line ${line_num} in ${file}: ${line}"
	   return 1
	 done < "${file}"
	# array support
	# IFS=',' read -r -a TAGS <<< "${INI_CONFIG["tags"]}"
}

function print_associative_array {
	local -n array=$1
	for x in "${!array[@]}"
	do
		msg "$(printf "[%s]=%s\n" "$x" "${array[$x]}")"
	done
}
function join_args {
	local IFS="${1}"
	shift
	echo "$*"
}
function find_matching_importer {
	local -n importer_config_out="${1?Must provide an output variable name}"
	local identifier="${2:-}"
	# declare -A importer_config=()
	if [[ -n "${identifier}" ]]
	then
		# search for specific file path
		# otherwise loop through all importers and find name
		if [[ -f "${identifier}" ]]
		then
			parse_ini "${identifier}" importer_config_out
			return
		else
			shopt -s nullglob
			for importer_file in *_importer.ini
			do
				parse_ini "${importer_file}" importer_config_out
				if [[ "${importer_config_out[name]}" == "${identifier}" ]]
				then
					shopt -u nullglob
					return
				fi
			done
			shopt -u nullglob
		fi
	else
		# TODO loop through all importers, check if transactions_file_path matches condition
		die 'Finding matching importer not supported. Use --importer <importer> for now'
	fi
	# unset INI_CONFIG
	return 1
}

function rename_txn_fields {
	local -n config="$1"
	local rename_args=""

	for key in "${!config[@]}"; do
		if [[ "$key" == *_column ]]; then
			local newname="${key%_column}"
			local oldname="${config[$key]}"
			if [[ "${newname}" == 'desc' ]]
			then
				newname='description'
			fi
			if [[ "${oldname}" == "${newname}" ]]
			then
				continue
			fi
	     	rename_args+="${oldname},${newname},"
	   fi
	done
	rename_args="${rename_args%,}"
	if [[ -n "$rename_args" ]]; then
		mlr --csv rename "$rename_args"
	else
		cat
	fi
}

function inject_constant_fields {
  local -n config="$1"
  local put_exprs=()

  for key in "${!config[@]}"; do
    if [[ "$key" == *_value ]]; then
      local field="${key%_value}"
      local value="${config[$key]}"
      put_exprs+=("\$$field=\"$value\"")
    fi
  done

  if (( ${#put_exprs[@]} )); then
    local put_chain
    put_chain=$(IFS='; '; echo "${put_exprs[*]}")
    mlr --csv put "$put_chain"
  else
    cat
  fi
}

function filter_relevant_columns {
	local columns="$(join_args , "${TXNS_FILE_COLUMNS[@]}")"
	mlr --csv cut -f "${columns}" 'then' 'cat'
}

function init_txns_file {
	local txns_file_path="${1?Must provide a txns file path}"
	if [[ ! -f "${txns_file_path}" ]]
	then
		join_args , "${TXNS_FILE_COLUMNS[@]}" > "${txns_file_path}"
	fi
}

function get_max_id {
	local db_file="${1}"
	if [ ! -f "${db_file}" ]
	then
		echo 0
	else
		mlr --csv filter '$id=~"^[0-9]+$"' then sort -nr id then head -n 1 "${TXNS_FILE_PATH}" | mlr --csv cut -f 'id' | tail -n 1
	fi
}

REQUIRED_COLUMNS=(date description amount account)
OPTIONAL_COLUMNS=(category)
TXNS_FILE_COLUMNS=(id date description amount account category)

function check_for_required_columns {
	local header
	header=$(head -n 1)
	IFS=',' read -r -a header_columns <<< "${header}"
	# IFS="${OLD_IFS}"
	local missing=()
	for required in "${REQUIRED_COLUMNS[@]}"
	do
		local found=false
		for col in "${header_columns[@]}"
		do
			if [[ "${col}" == "${required}" ]]
			then
				found=true
				break
			fi
		done
		if ! ${found}
		then
			missing+=("${required}")
		fi
	done

	if (( ${#missing[@]} > 0 ))
	then
		die "Error CSV header missing columns.\nHeader: ${header}\nMissing: $(join_args , "${missing[@]}")"
	fi
	# Emit header and pass through the rest of the stream
	echo "${header}"
	cat
}
function add_optional_columns_to_txns {
	local putexprs=()
	for col in "${OPTIONAL_COLUMNS[@]}"
	do
		put_exprs+=("if (!haskey(\$*, \"$col\")) { \$$col = \"\"}")
	done
	local put_chain
	put_chain=$(IFS='; '; echo "${put_exprs[*]}")
	mlr --csv put "${put_chain}"
	
}

function reorder_txn_fields {
	local fields
	fields=$(IFS=','; echo "${TXNS_FILE_COLUMNS[*]}")
	mlr --csv reorder -f "${fields}"
}

function add_id_column_to_txns {
	local start_id="${1}"
	mlr --csv put '
	  begin { @i = '"${start_id}"' }
	  $id = @i;
	  @i += 1
	' 'then' reorder -f id
}
function run_import {
	local import_file="$1"
	local importer_file="$2"
	local -A importer_config=()
	# find and load the matching importer
	if ! find_matching_importer importer_config "${importer_file}"
	then
		msg "Unable to find importer by path or name. Use --importer <name|path>. (e.g. --importer my_card_importer.ini)"
		return 1
	fi
	
	# init the txns db file if not present
	# get the next txn id to use
	# TODO consider more robust approach of using mlr to load txns file then merge with new txns before saving to file
	init_txns_file "${TXNS_FILE_PATH}"
	local next_id=$(( $(get_max_id "${TXNS_FILE_PATH}") + 1 ))

	# Load external txns
	# Transform: rename fields, filter out extras, add fields, reorder
	# Add ids then save in txns file
	# set -x
	mlr --csv --from "${import_file}" cat |
	rename_txn_fields importer_config |
	inject_constant_fields importer_config |
	# tee /dev/stderr |
	# check_for_required_columns | # TODO add back once impl works well
	filter_relevant_columns |
	add_optional_columns_to_txns |
	reorder_txn_fields |
	add_id_column_to_txns "${next_id}" |
	tail -n +2 >> "${TXNS_FILE_PATH}"
}

function import_cmd {
	local import_file=""
	local importer_file=""

	while [[ $# -gt 0 ]]; do
	  case "$1" in
	    --importer) importer_file="$2"; shift ;;
	    *) import_file="$1" ;;
	  esac
	  shift
	done

	# validate arguments
	if [[ -z "$import_file" || -z "$importer_file" ]]; then
	  msg "Usage: bashbudget import <file.csv> --importer <importer.ini>"
	  return 1
	fi
	if [[ ! -f "$import_file" ]]; then
	  msg "${import_file} must be an existing file"
	  return 1
	fi
	
	run_import "$import_file" "$importer_file"
}

function reports_totals {
    local FROM_DATE=""
    local TO_DATE=""
    local MONTHLY=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from)
                FROM_DATE="$2"
                shift
                ;;
            --to)
                TO_DATE="$2"
                shift
                ;;
            --monthly)
                MONTHLY=true
                ;;
            *)
                echo "Unknown option: $1" >&2
                return 1
                ;;
        esac
        shift
    done

    if [[ ! -f "${TXNS_FILE_PATH}" ]]; then
        echo "No transactions file found: ${TXNS_FILE_PATH}" >&2
        return 1
    fi

    local FILTER_EXPR=""
    if [[ -n "${FROM_DATE}" ]]; then
        FILTER_EXPR+='($date >= "'"${FROM_DATE}"'")'
    fi
    if [[ -n "${TO_DATE}" ]]; then
        if [[ -n "${FILTER_EXPR}" ]]; then
            FILTER_EXPR+=' && '
        fi
        FILTER_EXPR+='($date <= "'"${TO_DATE}"'")'
    fi

    local MLR_CHAIN=""
    if [[ -n "${FILTER_EXPR}" ]]; then
        MLR_CHAIN+="filter ${FILTER_EXPR} then "
    fi
    if [[ "${MONTHLY}" == true ]]; then
        MLR_CHAIN+='put $month = substr($date, 0, 7) then stats1 -a sum -f amount -g month,category'
    else
        MLR_CHAIN+='stats1 -a sum -f amount -g category'
    fi

    mlr --csv ${MLR_CHAIN} --from "${TXNS_FILE_PATH}"
}

function reports_cmd {
  local subcmd="$1"
  shift

  case "$subcmd" in
    totals) reports_totals "$@" ;;
    *) echo "Unknown report type: $subcmd" >&2; return 1 ;;
  esac
}

function main {
	if [[ $# -lt 1 ]]
	then
		msg "Must provide at least one command."
		usage 1
	fi
	case "$1" in
	    import)   import_cmd "${@:2}" ;;
	    reports)  reports_cmd "${@:2}" ;;
	    help|"")  usage ;;
	    *)        echo "Unknown command: $1" >&2; usage ;;
	  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]
then
	main "${@}"
fi
